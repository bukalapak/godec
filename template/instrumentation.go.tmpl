// Code generated by godec.

{{ $interface := .Name -}}
package decorator

import (
  "time"
  "{{ .PackagePath }}"
)

const interfaceName = "{{ $interface }}"

// {{ $interface }}Instrumentation
type {{ $interface }}Instrumentation struct {
  Decorated {{ .Package }}.{{ $interface }}
} 
{{ range .Methods }}
{{ $methodName := .Name }}
// {{ .Name }}
func (d *{{ $interface }}Instrumentation) {{ .Name }}({{ range $index, $element := .Params}}{{ if not (eq $index 0) }}, {{ end }}{{ .Name }} {{ .Type }} {{- end }}) ({{ range $index, $element := .ReturnValues}}{{ if not (eq $index 0) }}, {{ end }}type{{$index}} {{ .Type }} {{- end }}) {
  start := time.Now()
	{{ range $index, $element := .ReturnValues}} {{ if not (eq $index 0) }}, {{ end }} type{{$index}} {{- end }} = d.Decorated.A(a)
  
  {{captureLatency $methodName .ReturnValues}}  
	return 
}
{{ end }}



func captureLatency(methodName string, start time.Time, err error) {
	elapsedTime := time.Since(start).Seconds()
	if err != nil {
		instrument.ObserveLatency(interfaceName, methodName, "fail", elapsedTime)
		return
	}

	instrument.ObserveLatency(interfaceName, methodName, "ok", elapsedTime)

}